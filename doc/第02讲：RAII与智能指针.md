# RAII与智能指针

## 编译器自动生成的函数：全家桶

```c++
struct C {
    C();                                //默认构造函数

    C(C const &c);                      //拷贝构造函数
    C(C &&c);                           //移动构造函数（c++11）
    
    C &operator=C(C const &c);          //拷贝复制函数
    C &operator=C(C &&c);               //拷贝移动函数

    ~C();                               //解构函数
}
```

## 三五法则：规则类怪谈

1. 如果定义了**解构函数**，那么您必须同时定义或者删除**拷贝构造函数**和**拷贝赋值构造函数**，否则出错。
2. 如果一个类定义了**拷贝构造函数**，那么您必须同时定义或者删除**拷贝赋值函数**，否则出错，删除可能导致低效。
3. 如果一个类定义了**移动构造函数**，那么您必须同时定义或者删除**移动赋值函数**，否则出错，删除可能导致低效。
4. 如果一个类定义了**拷贝构造函数**和**拷贝赋值函数**，那么您必须最好同时定义**移动构造函数**或**移动赋值函数**，否则低效。

## 那些情况会触发“移动”

* 这些情况下编译器会调用移动

    ```cpp
    return v2     //v2作为返回值
    v1 = std::vector<int>(200)    //就地构造的v2
    v1 = std::move(v2)      //显式地移动
    ```

* 这些情况下编译器会调用拷贝

    ```cpp
    return std::as_const(v2)    //显式地拷贝
    v1 = v2     //默认拷贝
    ```

* 一下语句没有任何作用

    ```cpp
    std::move(v2)   //不会清空v2，需要清空可以用v2 = {} 或者 v2.clear()
    std::as_const(v2)   // //不会拷贝v2，需要拷贝可以用{auto _ = v2;}
    //这两个函数只是扶着转换类型，实际产生的移动/拷贝效果实在类的构造/赋值函数里
    ```

## shared_ptr

1. shared_ptr 需要维护一个 atomic 的引用计数器，效率低，需要额外的一块管理内存，访问实际对象需要二级指针，而且deleter使用了类型擦除技术。
2. 全部使用 shared_ptr，可能出现循环引用的问题，导致内存泄漏，依然需要使用不影响计数的原始指针或者weak_ptr来避免。

### 不影响shared_ptr计数：弱引用weak_ptr

1. 有时候我们希望维护一个 shared_ptr 的弱引用 weak_ptr，即：弱引用的拷贝与解构不影响其引用计数器。
2. 之后有需要时，可以通过 lock() 随时产生一个新的 shared_ptr 作为强引用。但不 lock 的时候不影响计数。
3. 如果失效（计数器归零）则 expired() 会返回 false，且 lock() 也会返回 nullptr。

### 智能指针：作为类的成员变量

* 可以在类中使用智能指针作为成员变量。需要根据实际情况（主要是看所有权），判断要用哪一种智能指针：

1. unique_ptr：**当该对象仅仅属于我时**。比如：父窗口中指向子窗口的指针。
2. 原始指针：**当该对象不属于我，但他释放前我必然被释放时。**有一定风险。比如：子窗口中指向父窗口的指针。
3. shared_ptr：**当该对象由多个对象共享时，或虽然该对象仅仅属于我，但有使用 weak_ptr 的需要。**
4. weak_ptr：**当该对象不属于我，且他释放后我仍可能不被释放时。**比如：指向窗口中上一次被点击的元素。
5. 初学者可以多用 shared_ptr 和 weak_ptr 的组合，更安全。

```c++
struct C {
    // 当一个类具有unique_ptr作为成员变量时
    std::unique_ptr<D> m_pD;

    // 拷贝构造/赋值函数会被隐式删除
    // C(C const &) = delete;
    // C &operator=(C const &) = delete;

    // 移动构造/赋值构造函数不受影响
    // C(C &&) = default;
    // C &operaot=(C &&) = default;
}
```

### 那是不是只要 shared_ptr 就行，不用 unique_ptr 了？

可以适当使用减轻初学者的压力，因为他的行为和 Python 等 GC 语言的引用计数机制很像。但从长远来看是不行的，因为：

1. shared_ptr 需要维护一个 atomic 的引用计数器，效率低，需要额外的一块管理内存，访问实际对象需要二级指针，而且 deleter 使用了类型擦除技术。
2. 全部用 shared_ptr，可能出现循环引用之类的问题，导致内存泄露，依然需要使用不影响计数的原始指针或者 weak_ptr 来避免。

## 三五法则：什么时候需要担心

一般来说，可以认为符合三五法则的类型是安全的。以下类型是安全的：

```cpp
* int id;                                        // 基础类型
* std::vector<int> arr;                  // STL 容器
* std::shared_ptr<Object> child; // 智能指针
* Object *parent;                         // 原始指针，如果是从智能指针里 .get() 出来的
```

以下对象是不安全的：

```cpp
* char *ptr;                                   // 原始指针，如果是通过 malloc/free 或 new/delete 分配的
* GLint tex;                                  // 是基础类型 int，但是对应着某种资源
* std::vector<Object *> objs;       // STL 容器，但存了不安全的对象
```